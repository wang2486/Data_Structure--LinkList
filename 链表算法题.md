```c
//设计一个算法删除单链表L（有头结点）中的一个最小值结点
bool LLink_DelMin(LNode_t *Head){
	if(Head == NULL || Head->next == NULL)  return false;
    LNode_t *min_prev = Head;          // 最小值结点的前驱指针
    LNode_t *cur = Head->next;        // 当前结点
    int min_val = cur->data;
    while (cur->next != NULL) {
        if (cur->next->data < min_val) {
            min_val = cur->next->data;
            min_prev = cur;            // 更新最小值结点的前驱
        }
        cur = cur->next;
    }
    // 删除最小值结点
    LNode_t *min = min_prev->next;
    min_prev->next = min->next;
    free(min);
    return true;
}
```

```c
/*假设该链表只给出了头指针 list。
 *在不改变链表的前提下，请设计一个尽可能高效的算法,查找链表中倒数第k个位置上的结点(k为正整数)。
 *若查找成功,算法输出该结点的 data 域的值，删除该结点，并返回 1
 *否则，只返回 0*/
int LLink_Searchreciprocal(LNode_t *list, int k) {
    if (list == NULL || k <= 0) return 0;
    LNode_t *fast = list->next;
    LNode_t *slow = list->next;
    LNode_t *prev = list;
    // 1. fast 指针先走 k 步
    for (int i = 0; i < k; ++i) {
        if (fast == NULL) return 0;  // 链表长度小于 k
        fast = fast->next;
    }
    // 2. 同时移动 fast 和 slow，直到 fast 到末尾
    while (fast != NULL) {
        fast = fast->next;
        prev = slow;
        slow = slow->next;
    }
    // 3. 删除 slow 指向的结点
    if (slow == NULL) return 0;  // 没找到
    printf("%d\n", slow->data);
    prev->next = slow->next;
    free(slow);
    return 1;
}
```

